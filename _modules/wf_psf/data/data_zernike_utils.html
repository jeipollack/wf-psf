

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wf_psf.data.data_zernike_utils &mdash; wf-psf 3.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9570fddd" />
      <link rel="stylesheet" type="text/css" href="../../../_static/twemoji.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=309026bb" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=af2ce170"></script>
      <script src="../../../_static/doctools.js?v=888ff710"></script>
      <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
      <script src="https://unpkg.com/twemoji@latest/dist/twemoji.min.js"></script>
      <script src="../../../_static/twemoji.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #ffb400" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            wf-psf
              <img src="../../../_static/cosmostat_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About WaveDiff</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../about.html">About</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installing WaveDiff</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dependencies.html">Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Running WaveDiff</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../basic_execution.html">Basic Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../configuration.html">Configuration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../z_ref.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #ffb400" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">wf-psf</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">wf_psf.data.data_zernike_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wf_psf.data.data_zernike_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Utilities for Zernike Data Handling.</span>

<span class="sd">This module provides utility functions for working with Zernike coefficients, including:</span>

<span class="sd">- Prior generation</span>
<span class="sd">- Data loading</span>
<span class="sd">- Conversions between physical displacements (e.g., defocus, centroid shifts) and modal Zernike coefficients</span>
<span class="sd">- Conversions between physical displacements (e.g., defocus, centroid shifts) and modal Zernike coefficients</span>

<span class="sd">Useful in contexts where Zernike representations are used to model optical aberrations or link physical misalignments to wavefront modes.</span>

<span class="sd">:Author: Tobias Liaudat &lt;tobias.liaudat@cea.fr&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tensorflow</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">tf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wf_psf.data.centroids</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_centroid_correction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wf_psf.data.data_handler</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_data_array</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wf_psf.instrument.ccd_misalignments</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_ccd_misalignment</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wf_psf.utils.read_config</span><span class="w"> </span><span class="kn">import</span> <span class="n">RecursiveNamespace</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="ZernikeInputs">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.ZernikeInputs">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ZernikeInputs</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Zernike-related inputs for PSF modeling, including priors and datasets for corrections.</span>

<span class="sd">    All fields are optional to allow flexibility across different run types (training, simulation, inference) and configurations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zernike_prior : Optional[np.ndarray]</span>
<span class="sd">        The true Zernike prior, if provided (e.g., from PDC). Can be None if not used or not available.</span>
<span class="sd">    centroid_dataset : Optional[Union[dict, &quot;RecursiveNamespace&quot;]]</span>
<span class="sd">        Dataset used for computing centroid corrections. Should contain both training and test sets if</span>
<span class="sd">        used. Can be None if centroid correction is not enabled or no dataset is available.</span>
<span class="sd">    misalignment_positions : Optional[np.ndarray]</span>
<span class="sd">        Positions used for computing CCD misalignment corrections. Should be available in inference mode if misalignment correction is enabled. Can be None if not used or not available.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">zernike_prior</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>  <span class="c1"># true prior, if provided (e.g. from PDC)</span>
    <span class="n">centroid_dataset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;RecursiveNamespace&quot;</span><span class="p">]</span>
    <span class="p">]</span>  <span class="c1"># only used in training/simulation</span>
    <span class="n">misalignment_positions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>  <span class="c1"># needed for CCD corrections</span></div>



<div class="viewcode-block" id="ZernikeInputsFactory">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.ZernikeInputsFactory">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ZernikeInputsFactory</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Factory class to build ZernikeInputs based on run type and dataset configuration.</span>

<span class="sd">    This class abstracts the logic of extracting the relevant Zernike-related inputs from the dataset based on the specified run type (training, simulation, inference) and model parameters. It handles the conditional logic for which inputs are needed and how to extract them, providing a clean interface for constructing the ZernikeInputs dataclass instance.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ZernikeInputsFactory.build">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.ZernikeInputsFactory.build">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">run_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">model_params</span><span class="p">,</span> <span class="n">prior</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZernikeInputs</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a ZernikeInputs dataclass instance based on run type and data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : Union[dict, DataConfigHandler]</span>
<span class="sd">            Dataset object containing star positions, priors, and optionally pixel data.</span>
<span class="sd">        run_type : str</span>
<span class="sd">            One of &#39;training&#39;, &#39;simulation&#39;, or &#39;inference&#39;.</span>
<span class="sd">        model_params : RecursiveNamespace</span>
<span class="sd">            Model parameters, including flags for prior/corrections.</span>
<span class="sd">        prior : Optional[np.ndarray]</span>
<span class="sd">            An explicitly passed prior (overrides any inferred one if provided).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ZernikeInputs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">centroid_dataset</span><span class="p">,</span> <span class="n">positions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">run_type</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;training&quot;</span><span class="p">,</span> <span class="s2">&quot;simulation&quot;</span><span class="p">,</span> <span class="s2">&quot;metrics&quot;</span><span class="p">}:</span>
            <span class="n">stamps</span> <span class="o">=</span> <span class="n">get_data_array</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">run_type</span><span class="p">,</span> <span class="n">train_key</span><span class="o">=</span><span class="s2">&quot;noisy_stars&quot;</span><span class="p">,</span> <span class="n">test_key</span><span class="o">=</span><span class="s2">&quot;stars&quot;</span>
            <span class="p">)</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">get_data_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">run_type</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;masks&quot;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">centroid_dataset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stamps&quot;</span><span class="p">:</span> <span class="n">stamps</span><span class="p">,</span> <span class="s2">&quot;masks&quot;</span><span class="p">:</span> <span class="n">masks</span><span class="p">}</span>

            <span class="n">positions</span> <span class="o">=</span> <span class="n">get_data_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">run_type</span><span class="o">=</span><span class="n">run_type</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;positions&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">model_params</span><span class="o">.</span><span class="n">use_prior</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Explicit prior provided; ignoring dataset-based prior.&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prior</span> <span class="o">=</span> <span class="n">get_np_zernike_prior</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">run_type</span> <span class="o">==</span> <span class="s2">&quot;inference&quot;</span><span class="p">:</span>
            <span class="n">stamps</span> <span class="o">=</span> <span class="n">get_data_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">run_type</span><span class="o">=</span><span class="n">run_type</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;sources&quot;</span><span class="p">)</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">get_data_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">run_type</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;masks&quot;</span><span class="p">,</span> <span class="n">allow_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">centroid_dataset</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stamps&quot;</span><span class="p">:</span> <span class="n">stamps</span><span class="p">,</span> <span class="s2">&quot;masks&quot;</span><span class="p">:</span> <span class="n">masks</span><span class="p">}</span>

            <span class="n">positions</span> <span class="o">=</span> <span class="n">get_data_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">run_type</span><span class="o">=</span><span class="n">run_type</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;positions&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">model_params</span><span class="o">.</span><span class="n">use_prior</span><span class="p">:</span>
                <span class="c1"># Try to extract prior from `data`, if present</span>
                <span class="n">prior</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="s2">&quot;zernike_prior&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zernike_prior&quot;</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;model_params.use_prior=True but no prior found in inference data. Proceeding with None.&quot;</span>
                    <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported run_type: </span><span class="si">{</span><span class="n">run_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ZernikeInputs</span><span class="p">(</span>
            <span class="n">zernike_prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span>
            <span class="n">centroid_dataset</span><span class="o">=</span><span class="n">centroid_dataset</span><span class="p">,</span>
            <span class="n">misalignment_positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="get_np_zernike_prior">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.get_np_zernike_prior">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_np_zernike_prior</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the zernike prior from the provided dataset.</span>

<span class="sd">    This method concatenates the stars from both the training</span>
<span class="sd">    and test datasets to obtain the full prior.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : DataConfigHandler</span>
<span class="sd">        Object containing training and test datasets.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zernike_prior : np.ndarray</span>
<span class="sd">        Numpy array containing the full prior.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zernike_prior</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">training_data</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;zernike_prior&quot;</span><span class="p">],</span>
            <span class="n">data</span><span class="o">.</span><span class="n">test_data</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;zernike_prior&quot;</span><span class="p">],</span>
        <span class="p">),</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">zernike_prior</span></div>



<div class="viewcode-block" id="pad_contribution_to_order">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.pad_contribution_to_order">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pad_contribution_to_order</span><span class="p">(</span><span class="n">contribution</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">max_order</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pad a Zernike contribution array to the max Zernike order.&quot;&quot;&quot;</span>
    <span class="n">current_order</span> <span class="o">=</span> <span class="n">contribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pad_width</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_order</span> <span class="o">-</span> <span class="n">current_order</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">contribution</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="combine_zernike_contributions">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.combine_zernike_contributions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">combine_zernike_contributions</span><span class="p">(</span><span class="n">contributions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine multiple Zernike contributions, padding each to the max order before summing.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">contributions</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No contributions provided.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contributions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">contributions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">max_order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">contrib</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">contrib</span> <span class="ow">in</span> <span class="n">contributions</span><span class="p">)</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">contributions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_samples</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">contributions</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All contributions must have the same number of samples.&quot;</span><span class="p">)</span>

    <span class="n">combined</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">max_order</span><span class="p">))</span>
    <span class="c1"># Pad each contribution to the max order and sum them</span>
    <span class="k">for</span> <span class="n">contrib</span> <span class="ow">in</span> <span class="n">contributions</span><span class="p">:</span>
        <span class="n">padded</span> <span class="o">=</span> <span class="n">pad_contribution_to_order</span><span class="p">(</span><span class="n">contrib</span><span class="p">,</span> <span class="n">max_order</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">+=</span> <span class="n">padded</span>

    <span class="k">return</span> <span class="n">combined</span></div>



<div class="viewcode-block" id="pad_tf_zernikes">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.pad_tf_zernikes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pad_tf_zernikes</span><span class="p">(</span><span class="n">zk_param</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">zk_prior</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">n_zks_total</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad the Zernike coefficient tensors to match the specified total number of Zernikes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zk_param : tf.Tensor</span>
<span class="sd">        Zernike coefficients for the parametric part. Shape [batch, n_zks_param, 1, 1].</span>
<span class="sd">    zk_prior : tf.Tensor</span>
<span class="sd">        Zernike coefficients for the prior part. Shape [batch, n_zks_prior, 1, 1].</span>
<span class="sd">    n_zks_total : int</span>
<span class="sd">        Total number of Zernikes to pad to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padded_zk_param : tf.Tensor</span>
<span class="sd">        Padded Zernike coefficients for the parametric part. Shape [batch, n_zks_total, 1, 1].</span>
<span class="sd">    padded_zk_prior : tf.Tensor</span>
<span class="sd">        Padded Zernike coefficients for the prior part. Shape [batch, n_zks_total, 1, 1].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pad_num_param</span> <span class="o">=</span> <span class="n">n_zks_total</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">zk_param</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pad_num_prior</span> <span class="o">=</span> <span class="n">n_zks_total</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">zk_prior</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">padded_zk_param</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">pad_num_param</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">zk_param</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_num_param</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]),</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">zk_param</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">padded_zk_prior</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">pad_num_prior</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">zk_prior</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_num_prior</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]),</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">zk_prior</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">padded_zk_param</span><span class="p">,</span> <span class="n">padded_zk_prior</span></div>



<div class="viewcode-block" id="assemble_zernike_contributions">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.assemble_zernike_contributions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assemble_zernike_contributions</span><span class="p">(</span>
    <span class="n">model_params</span><span class="p">,</span>
    <span class="n">zernike_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">centroid_dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble Zernike contributions from prior, centroid correction, and CCD misalignment.</span>

<span class="sd">    This function checks the model parameters to determine which contributions to include, computes each contribution as needed, and combines them into a single Zernike contribution tensor. It handles the logic for when certain contributions are not used or not available, ensuring that the final output is correctly shaped and contains the appropriate information based on the configuration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model_params : RecursiveNamespace</span>
<span class="sd">        Parameters controlling which contributions to apply.</span>
<span class="sd">    zernike_prior : Optional[np.ndarray or tf.Tensor]</span>
<span class="sd">        The precomputed Zernike prior. Can be either a NumPy array or a TensorFlow tensor.</span>
<span class="sd">        If a Tensor, will be converted to NumPy in eager mode.</span>
<span class="sd">    centroid_dataset : Optional[object]</span>
<span class="sd">        Dataset used to compute centroid correction. Must have both training and test sets.</span>
<span class="sd">    positions : Optional[np.ndarray or tf.Tensor]</span>
<span class="sd">        Positions used for computing CCD misalignment. Must be available in inference mode.</span>
<span class="sd">    batch_size : int</span>
<span class="sd">        Batch size for centroid correction.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tf.Tensor</span>
<span class="sd">        A tensor representing the full Zernike contribution map.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">zernike_contribution_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Prior</span>
    <span class="k">if</span> <span class="n">model_params</span><span class="o">.</span><span class="n">use_prior</span> <span class="ow">and</span> <span class="n">zernike_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Adding Zernike prior...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zernike_prior</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tf</span><span class="o">.</span><span class="n">executing_eagerly</span><span class="p">():</span>
                <span class="n">zernike_prior</span> <span class="o">=</span> <span class="n">zernike_prior</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Zernike prior is a TensorFlow tensor but eager execution is disabled. &quot;</span>
                    <span class="s2">&quot;Cannot call `.numpy()` outside of eager mode.&quot;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zernike_prior</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unsupported zernike_prior type. Must be np.ndarray or tf.Tensor.&quot;</span>
            <span class="p">)</span>
        <span class="n">zernike_contribution_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zernike_prior</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping Zernike prior (not used or not provided).&quot;</span><span class="p">)</span>

    <span class="c1"># Centroid correction (tip/tilt)</span>
    <span class="k">if</span> <span class="n">model_params</span><span class="o">.</span><span class="n">correct_centroids</span> <span class="ow">and</span> <span class="n">centroid_dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing centroid correction...&quot;</span><span class="p">)</span>
        <span class="n">centroid_correction</span> <span class="o">=</span> <span class="n">compute_centroid_correction</span><span class="p">(</span>
            <span class="n">model_params</span><span class="p">,</span> <span class="n">centroid_dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span>
        <span class="p">)</span>
        <span class="n">zernike_contribution_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid_correction</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping centroid correction (not enabled or no dataset).&quot;</span><span class="p">)</span>

    <span class="c1"># CCD misalignment (focus term)</span>
    <span class="k">if</span> <span class="n">model_params</span><span class="o">.</span><span class="n">add_ccd_misalignments</span> <span class="ow">and</span> <span class="n">positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing CCD misalignment correction...&quot;</span><span class="p">)</span>
        <span class="n">ccd_misalignment</span> <span class="o">=</span> <span class="n">compute_ccd_misalignment</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>
        <span class="n">zernike_contribution_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccd_misalignment</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Skipping CCD misalignment correction (not enabled or no positions).&quot;</span>
        <span class="p">)</span>

    <span class="c1"># If no contributions, return zeros tensor to avoid crashes</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">zernike_contribution_list</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No Zernike contributions found. Returning zero tensor.&quot;</span><span class="p">)</span>
        <span class="c1"># Infer batch size and zernike order from model_params</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">n_zks</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model_params</span><span class="o">.</span><span class="n">param_hparams</span><span class="p">,</span> <span class="s2">&quot;n_zernikes&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_zks</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">combined_zernike_prior</span> <span class="o">=</span> <span class="n">combine_zernike_contributions</span><span class="p">(</span><span class="n">zernike_contribution_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">combined_zernike_prior</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>



<div class="viewcode-block" id="shift_x_y_to_zk1_2_wavediff">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.shift_x_y_to_zk1_2_wavediff">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">shift_x_y_to_zk1_2_wavediff</span><span class="p">(</span><span class="n">dxy</span><span class="p">,</span> <span class="n">tel_focal_length</span><span class="o">=</span><span class="mf">24.5</span><span class="p">,</span> <span class="n">tel_diameter</span><span class="o">=</span><span class="mf">1.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Zernike 1(2) for a given shifts in x(y) in WaveDifff conventions.</span>

<span class="sd">    All inputs should be in [m].</span>
<span class="sd">    A displacement of, for example, 0.5 pixels should be scaled with the corresponding pixel scale,</span>
<span class="sd">    e.g. 12[um], to get a displacement in [m], which would be `dxy=0.5*12e-6`.</span>

<span class="sd">    The output zernike coefficient is in [um] units as expected by wavediff.</span>

<span class="sd">    To apply match the centroid with a `dx` that has a corresponding `zk1`,</span>
<span class="sd">    the new PSF should be generated with `-zk1`.</span>

<span class="sd">    The same applies to `dy` and `zk2`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dxy : float</span>
<span class="sd">        Centroid shift in [m]. It can be on the x-axis or the y-axis.</span>
<span class="sd">    tel_focal_length : float</span>
<span class="sd">        Telescope focal length in [m].</span>
<span class="sd">    tel_diameter : float</span>
<span class="sd">        Telescope aperture diameter in [m].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reference_pix_sampling</span> <span class="o">=</span> <span class="mf">12e-6</span>
    <span class="n">zernike_norm_factor</span> <span class="o">=</span> <span class="mf">2.0</span>

    <span class="c1"># return zernike_norm_factor * (dx/reference_pix_sampling) / (tel_focal_length * tel_diameter / 2)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">zernike_norm_factor</span>
        <span class="o">*</span> <span class="p">(</span><span class="n">tel_diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="n">dxy</span> <span class="o">/</span> <span class="n">reference_pix_sampling</span><span class="p">)</span> <span class="o">/</span> <span class="n">tel_focal_length</span><span class="p">))</span>
        <span class="o">*</span> <span class="mf">3.0</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="compute_zernike_tip_tilt">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.compute_zernike_tip_tilt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_zernike_tip_tilt</span><span class="p">(</span>
    <span class="n">star_images</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">star_masks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pixel_sampling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">12e-6</span><span class="p">,</span>
    <span class="n">reference_shifts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">],</span>
    <span class="n">sigma_init</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
    <span class="n">n_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Zernike tip-tilt corrections for a batch of PSF images.</span>

<span class="sd">    This function estimates the centroid shifts of multiple PSFs and computes</span>
<span class="sd">    the corresponding Zernike tip-tilt corrections to align them with a reference.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    star_images : np.ndarray</span>
<span class="sd">        A batch of PSF images (3D array of shape `(num_images, height, width)`).</span>
<span class="sd">    star_masks : np.ndarray, optional</span>
<span class="sd">        A batch of masks (same shape as `star_postage_stamps`). Each mask can have:</span>
<span class="sd">        - `0` to ignore the pixel.</span>
<span class="sd">        - `1` to fully consider the pixel.</span>
<span class="sd">        - Values in `(0,1]` as weights for partial consideration.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    pixel_sampling : float, optional</span>
<span class="sd">        The pixel size in meters. Defaults to `12e-6 m` (12 microns).</span>
<span class="sd">    reference_shifts : list[float], optional</span>
<span class="sd">        The target centroid shifts in pixels, specified as `[dy, dx]`.</span>
<span class="sd">        Defaults to `[-1/3, -1/3]` (nominal Euclid conditions).</span>
<span class="sd">    sigma_init : float, optional</span>
<span class="sd">        Initial standard deviation for centroid estimation. Default is `2.5`.</span>
<span class="sd">    n_iter : int, optional</span>
<span class="sd">        Number of iterations for centroid refinement. Default is `20`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        An array of shape `(num_images, 2)`, where:</span>
<span class="sd">        - Column 0 contains `Zk1` (tip) values.</span>
<span class="sd">        - Column 1 contains `Zk2` (tilt) values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function processes all images at once using vectorized operations.</span>
<span class="sd">    - The Zernike coefficients are computed in the WaveDiff convention.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">wf_psf.data.centroids</span><span class="w"> </span><span class="kn">import</span> <span class="n">CentroidEstimator</span>

    <span class="c1"># Vectorize the centroid computation</span>
    <span class="n">centroid_estimator</span> <span class="o">=</span> <span class="n">CentroidEstimator</span><span class="p">(</span>
        <span class="n">im</span><span class="o">=</span><span class="n">star_images</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">star_masks</span><span class="p">,</span> <span class="n">sigma_init</span><span class="o">=</span><span class="n">sigma_init</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="n">n_iter</span>
    <span class="p">)</span>

    <span class="n">shifts</span> <span class="o">=</span> <span class="n">centroid_estimator</span><span class="o">.</span><span class="n">get_intra_pixel_shifts</span><span class="p">()</span>

    <span class="c1"># Ensure reference_shifts is a NumPy array (if it&#39;s not already)</span>
    <span class="n">reference_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reference_shifts</span><span class="p">)</span>

    <span class="c1"># Reshape to ensure it&#39;s a column vector (1, 2)</span>
    <span class="n">reference_shifts</span> <span class="o">=</span> <span class="n">reference_shifts</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Broadcast reference_shifts to match the shape of shifts</span>
    <span class="n">reference_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">reference_shifts</span><span class="p">,</span> <span class="n">shifts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Compute displacements</span>
    <span class="n">displacements</span> <span class="o">=</span> <span class="n">reference_shifts</span> <span class="o">-</span> <span class="n">shifts</span>  <span class="c1">#</span>

    <span class="c1"># Ensure the correct axis order for displacements (x-axis, then y-axis)</span>
    <span class="n">displacements_swapped</span> <span class="o">=</span> <span class="n">displacements</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># Adjust axis order if necessary</span>

    <span class="c1"># Call shift_x_y_to_zk1_2_wavediff directly on the vector of displacements</span>
    <span class="n">zk1_2_array</span> <span class="o">=</span> <span class="n">shift_x_y_to_zk1_2_wavediff</span><span class="p">(</span>
        <span class="n">displacements_swapped</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">*</span> <span class="n">pixel_sampling</span>
    <span class="p">)</span>  <span class="c1"># vectorized call</span>

    <span class="c1"># Reshape the result back to the original shape of displacements</span>
    <span class="n">zk1_2_array</span> <span class="o">=</span> <span class="n">zk1_2_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">displacements</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">zk1_2_array</span></div>



<div class="viewcode-block" id="defocus_to_zk4_zemax">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.defocus_to_zk4_zemax">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">defocus_to_zk4_zemax</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="n">tel_focal_length</span><span class="o">=</span><span class="mf">24.5</span><span class="p">,</span> <span class="n">tel_diameter</span><span class="o">=</span><span class="mf">1.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Zernike 4 value for a given defocus in zemax conventions.</span>

<span class="sd">    All inputs should be in [m].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dz : float</span>
<span class="sd">        Shift in the z-axis, perpendicular to the focal plane. Units in [m].</span>
<span class="sd">    tel_focal_length : float</span>
<span class="sd">        Telescope focal length in [m].</span>
<span class="sd">    tel_diameter : float</span>
<span class="sd">        Telescope aperture diameter in [m].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Base calculation</span>
    <span class="n">zk4</span> <span class="o">=</span> <span class="n">dz</span> <span class="o">/</span> <span class="p">(</span><span class="mf">8.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">tel_focal_length</span> <span class="o">/</span> <span class="n">tel_diameter</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Apply Z4 normalisation</span>
    <span class="c1"># This step depends on the normalisation of the Zernike basis used</span>
    <span class="n">zk4</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># Convert to waves with a reference of 800nm</span>
    <span class="n">zk4</span> <span class="o">/=</span> <span class="mf">800e-9</span>
    <span class="c1"># Remove the peak to valley value</span>
    <span class="n">zk4</span> <span class="o">/=</span> <span class="mf">2.0</span>

    <span class="k">return</span> <span class="n">zk4</span></div>



<div class="viewcode-block" id="defocus_to_zk4_wavediff">
<a class="viewcode-back" href="../../../_autosummary/wf_psf.data.data_zernike_utils.html#wf_psf.data.data_zernike_utils.defocus_to_zk4_wavediff">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">defocus_to_zk4_wavediff</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="n">tel_focal_length</span><span class="o">=</span><span class="mf">24.5</span><span class="p">,</span> <span class="n">tel_diameter</span><span class="o">=</span><span class="mf">1.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Zernike 4 value for a given defocus in WaveDifff conventions.</span>

<span class="sd">    All inputs should be in [m].</span>

<span class="sd">    The output zernike coefficient is in [um] units as expected by wavediff.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dz : float</span>
<span class="sd">        Shift in the z-axis, perpendicular to the focal plane. Units in [m].</span>
<span class="sd">    tel_focal_length : float</span>
<span class="sd">        Telescope focal length in [m].</span>
<span class="sd">    tel_diameter : float</span>
<span class="sd">        Telescope aperture diameter in [m].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Base calculation</span>
    <span class="n">zk4</span> <span class="o">=</span> <span class="n">dz</span> <span class="o">/</span> <span class="p">(</span><span class="mf">8.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">tel_focal_length</span> <span class="o">/</span> <span class="n">tel_diameter</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Apply Z4 normalisation</span>
    <span class="c1"># This step depends on the normalisation of the Zernike basis used</span>
    <span class="n">zk4</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Remove the peak to valley value</span>
    <span class="n">zk4</span> <span class="o">/=</span> <span class="mf">2.0</span>

    <span class="c1"># Change units to [um] as Wavediff uses</span>
    <span class="n">zk4</span> <span class="o">*=</span> <span class="mf">1e6</span>

    <span class="k">return</span> <span class="n">zk4</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 20232026, CosmoStat.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-XXXXXXXXXX', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>